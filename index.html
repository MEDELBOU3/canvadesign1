<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Studio - Advanced Design Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #3f37c9;
            --accent: #4cc9f0;
            --dark: #212529;
            --light: #f8f9fa;
            --gray: #6c757d;
            --gray-light: #e9ecef;
            --success: #38b000;
            --warning: #ffaa00;
            --danger: #d00000;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --radius: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            background-color: var(--light);
            color: var(--dark);
        }

        /* Header */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: white;
            border-bottom: 1px solid var(--gray-light);
            box-shadow: var(--shadow);
            z-index: 10;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-actions {
            display: flex;
            gap: 15px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: white;
            color: var(--dark);
            border: 1px solid var(--gray-light);
            padding: 8px 16px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-secondary:hover {
            background-color: var(--gray-light);
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background-color: white;
            border-right: 1px solid var(--gray-light);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-section {
            padding: 15px;
            border-bottom: 1px solid var(--gray-light);
        }

        .sidebar-section h3 {
            margin-bottom: 12px;
            color: var(--dark);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .tool-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 10px 5px;
            border-radius: var(--radius);
            background-color: white;
            border: 1px solid var(--gray-light);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.75rem;
        }

        .tool-btn:hover {
            background-color: var(--gray-light);
            transform: translateY(-2px);
        }

        .tool-btn i {
            font-size: 1.2rem;
            color: var(--dark);
        }

        .tool-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .tool-btn.active i {
            color: white;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid white;
            box-shadow: 0 0 0 1px var(--gray-light);
        }

        .color-swatch.active {
            transform: scale(1.2);
            box-shadow: 0 0 0 2px var(--primary);
        }

        .slider-control {
            margin: 12px 0;
        }

        .slider-control label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
        }

        .slider-control input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--gray-light);
            border-radius: 10px;
            appearance: none;
        }

        .slider-control input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        .font-select {
            width: 100%;
            padding: 8px;
            border-radius: var(--radius);
            border: 1px solid var(--gray-light);
            margin-bottom: 10px;
        }

        .text-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .text-control-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--gray-light);
            background: white;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .text-control-btn:hover {
            background-color: var(--gray-light);
        }

        .text-control-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #f0f2f5;
            overflow: hidden;
        }

        .canvas-toolbar {
            padding: 10px 20px;
            display: flex;
            align-items: center;
            background-color: white;
            border-bottom: 1px solid var(--gray-light);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 20px;
        }

        .zoom-level {
            font-size: 0.9rem;
            color: var(--gray);
        }

        .history-controls {
            display: flex;
            gap: 10px;
        }

        .icon-btn {
            background: none;
            border: none;
            font-size: 1rem;
            color: var(--gray);
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: var(--transition);
        }

        .icon-btn:hover {
            background-color: var(--gray-light);
            color: var(--dark);
        }

        .icon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .canvas-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: auto;
            padding: 20px;
            margin-top: 30px;
        }

        .canvas-container {
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        #canvas {
            background-color: white;
        }

        /* Right Panel */
        .right-panel {
            width: 280px;
            background-color: white;
            border-left: 1px solid var(--gray-light);
            overflow-y: auto;
        }

        .panel-section {
            padding: 15px;
            border-bottom: 1px solid var(--gray-light);
        }

        .panel-section h3 {
            margin-bottom: 12px;
            color: var(--dark);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-radius: var(--radius);
            margin-bottom: 5px;
            background-color: white;
            border: 1px solid var(--gray-light);
            cursor: pointer;
            transition: var(--transition);
        }

        .layer-item:hover {
            background-color: var(--gray-light);
        }

        .layer-item.active {
            background-color: rgba(67, 97, 238, 0.1);
            border-color: var(--primary);
        }

        .layer-item-name {
            flex: 1;
            font-size: 0.9rem;
        }

        .layer-item-actions {
            display: flex;
            gap: 5px;
        }

        .layer-visibility {
            opacity: 0.6;
            cursor: pointer;
        }

        .layer-visibility:hover {
            opacity: 1;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .template-item {
            border-radius: var(--radius);
            overflow: hidden;
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid var(--gray-light);
        }

        .template-item:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow);
        }

        .template-item img {
            width: 100%;
            height: 100px;
            object-fit: cover;
        }

        /* Custom Color Picker */
        .color-picker-container {
            margin-top: 10px;
        }

        input[type="color"] {
            width: 100%;
            height: 35px;
            border: 1px solid var(--gray-light);
            border-radius: var(--radius);
            cursor: pointer;
        }

        /* Templates for placeholders */
        .placeholder-img {
            width: 100%;
            height: 100px;
            background-color: var(--gray-light);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--gray);
            font-size: 0.8rem;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            width: 500px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .modal-header {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--gray-light);
        }

        .modal-header h2 {
            font-size: 1.2rem;
            font-weight: 500;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--gray);
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 15px 20px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid var(--gray-light);
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--gray-light);
            border-radius: var(--radius);
            font-size: 1rem;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background-color: var(--dark);
            color: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast-success {
            background-color: var(--success);
        }

        .toast-error {
            background-color: var(--danger);
        }

        .tool-btn.active, .text-control-btn.active {
            background-color: var(--primary-color-light);
            color: var(--primary-color);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
         /* Style for Gradient Section */
        .gradient-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }
        .gradient-controls label {
            display: block;
            margin-bottom: 4px;
            font-size: 0.9em;
            font-weight: 500;
        }
        .gradient-controls select,
        .gradient-controls input[type="color"] {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
             box-sizing: border-box; /* Include padding/border in width */
        }
         .gradient-color-inputs {
             display: flex;
             gap: 8px;
             align-items: center;
         }
         .gradient-color-inputs label { margin-bottom: 0; }
         .gradient-color-inputs input[type="color"] {
             width: 40px; /* Smaller color inputs */
             height: 25px;
             padding: 2px;
             border: none;
             background: none; /* Remove default background */
             cursor: pointer;
         }

         /* Figma Integration Styles */
.figma-credentials {
    margin-bottom: 15px;
    padding: 10px;
    background-color: #f5f5f5;
    border-radius: 5px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.figma-credential-input {
    flex: 1;
    min-width: 150px;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
}

.figma-btn {
    padding: 8px 12px;
    background-color: #0d99ff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.figma-btn:hover {
    background-color: #0078cc;
}

.template-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 10px;
    margin-top: 10px;
}

.template-item {
    transition: transform 0.2s ease;
    border-radius: 4px;
    overflow: hidden;
}

.template-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

    </style>
</head>
<body>
    <!-- Header -->
    <header class="app-header">
        <div class="logo">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>
            </svg>
            Canvas Studio
        </div>
        <div class="header-actions">
            <button class="btn-secondary" onclick="showNameModal()">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                </svg>
                Untitled Design
            </button>
            <button class="btn-secondary" onclick="downloadDesign()">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Download
            </button>
            <button class="btn-primary" onclick="saveDesign()">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                    <polyline points="17 21 17 13 7 13 7 21"></polyline>
                    <polyline points="7 3 7 8 15 8"></polyline>
                </svg>
                Save
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <!-- Elements Section -->
            <div class="sidebar-section">
                <h3>Elements</h3>
                <div class="tool-grid">
                    <button class="tool-btn" onclick="addRectangle()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        </svg>
                        Rectangle
                    </button>
                    <button class="tool-btn" onclick="addCircle()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                        Circle
                    </button>
                    <button class="tool-btn" onclick="addTriangle()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="12 2 19 21 5 21 12 2"></polygon>
                        </svg>
                        Triangle
                    </button>
                    <button class="tool-btn" onclick="addText()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="4 7 4 4 20 4 20 7"></polyline>
                            <line x1="9" y1="20" x2="15" y2="20"></line>
                            <line x1="12" y1="4" x2="12" y2="20"></line>
                        </svg>
                        Text
                    </button>
                    <button class="tool-btn" onclick="addLine()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        Line
                    </button>
                    <button class="tool-btn" onclick="addArrow()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                        Arrow
                    </button>
                    <button class="tool-btn" onclick="addStar()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                        </svg>
                        Star
                    </button>
                    <button class="tool-btn" id="pencilBtn" onclick="toggleDrawingMode('pencil')">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                             <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                        </svg>
                        Pencil
                    </button>
                     <button class="tool-btn" id="eraserBtn" onclick="toggleDrawingMode('eraser')">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20 16.5l-1.5-1.5a2.828 2.828 0 0 0-4 0L6 23.5 2 22l1.5-4.5L12 9l4 4 .5.5a2.828 2.828 0 0 0 4 0l-1.5-1.5z"></path><path d="M18 11l-1.5-1.5a2.828 2.828 0 0 0-4 0L3.5 19.5 2 22l2.5-1.5L14 11l4 4 .5.5a2.828 2.828 0 0 0 4 0l-1.5-1.5z"></path> // More complex eraser icon
                             <path d="M18.6 5.4c.3-.3.3-.7 0-1l-1.1-1.1c-.3-.3-.7-.3-1 0L6 13.8V16h2.2l10.4-10.6zm-4.3 0L10 9.7 11.3 11l4.3-4.3-1.3-1.3z M3 21v-2h18v2H3z"></path> // Simpler eraser icon
                        </svg>
                        Eraser
                    </button>
                    <button class="tool-btn" onclick="uploadImage()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        Image
                    </button>
                    <button class="tool-btn" onclick="showGridModal()">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="7" height="7"></rect>
                            <rect x="14" y="3" width="7" height="7"></rect>
                            <rect x="14" y="14" width="7" height="7"></rect>
                            <rect x="3" y="14" width="7" height="7"></rect>
                        </svg>
                        Grid
                    </button>
                </div>
            </div>

            <!-- Colors Section -->
            <div class="sidebar-section">
                <h3>Colors</h3>
                <div class="color-grid">
                    <div class="color-swatch" style="background-color: #ff5252;" onclick="setColor('#ff5252')"></div>
                    <div class="color-swatch" style="background-color: #ff9800;" onclick="setColor('#ff9800')"></div>
                    <div class="color-swatch" style="background-color: #ffeb3b;" onclick="setColor('#ffeb3b')"></div>
                    <div class="color-swatch" style="background-color: #4caf50;" onclick="setColor('#4caf50')"></div>
                    <div class="color-swatch" style="background-color: #2196f3;" onclick="setColor('#2196f3')"></div>
                    <div class="color-swatch" style="background-color: #9c27b0;" onclick="setColor('#9c27b0')"></div>
                    <div class="color-swatch" style="background-color: #ffffff;" onclick="setColor('#ffffff')"></div>
                    <div class="color-swatch" style="background-color: #e0e0e0;" onclick="setColor('#e0e0e0')"></div>
                    <div class="color-swatch" style="background-color: #9e9e9e;" onclick="setColor('#9e9e9e')"></div>
                    <div class="color-swatch" style="background-color: #616161;" onclick="setColor('#616161')"></div>
                    <div class="color-swatch" style="background-color: #212121;" onclick="setColor('#212121')"></div>
                    <div class="color-swatch" style="background-color: #000000;" onclick="setColor('#000000')"></div>
                </div>
                <div class="color-picker-container">
                    <label>Custom color:</label>
                    <input type="color" id="colorPicker" onchange="setColor(this.value)">
                </div>

                 <!-- Gradient Controls -->
                <div class="gradient-controls">
                    <h3>Gradient Fill</h3>
                    <div>
                        <label for="gradientType">Type:</label>
                        <select id="gradientType">
                            <option value="linear">Linear</option>
                            <option value="radial">Radial</option>
                        </select>
                    </div>
                    <div class="gradient-color-inputs">
                        <label for="gradientColor1">Color 1:</label>
                        <input type="color" id="gradientColor1" value="#ffffff">
                        <label for="gradientColor2">Color 2:</label>
                        <input type="color" id="gradientColor2" value="#000000">
                    </div>
                    <button class="btn-secondary" style="width: 100%; margin-top: 5px;" onclick="applyGradient()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1" /><stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" /></linearGradient></defs><ellipse cx="12" cy="12" rx="10" ry="10" fill="url(#grad1)" /></svg>
                         Apply Gradient
                    </button>
                </div>
            </div>

            <!-- Style Controls Section -->
            <div class="sidebar-section">
                <h3>Style</h3>
                <div class="slider-control">
                    <label>
                        <span>Opacity</span>
                        <span id="opacityValue">100%</span>
                    </label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="100" onchange="changeOpacity(this.value)">
                </div>
                <div class="slider-control">
                    <label>
                        <span>Border Width</span>
                        <span id="borderWidthValue">1px</span>
                    </label>
                    <input type="range" id="borderWidthSlider" min="0" max="20" value="1" onchange="changeBorderWidth(this.value)">
                </div>
                <div class="color-picker-container">
                    <label>Border color:</label>
                    <input type="color" id="borderColorPicker" value="#000000" onchange="changeBorderColor(this.value)">
                </div>
                <button class="btn-secondary" style="width: 100%; margin-top: 10px;" onclick="addShadow()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                        <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                        <path d="M2 2l7.586 7.586"></path>
                        <circle cx="11" cy="11" r="2"></circle>
                    </svg>
                    Add Shadow
                </button>
                <button class="btn-secondary" style="width: 100%; margin-top: 10px;" onclick="removeStyles()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>
                    </svg>
                    Reset Styles
                </button>
            </div>

            <!-- Text Controls Section -->
            <div class="sidebar-section">
                <h3>Text</h3>
                <select class="font-select" id="fontSelect" onchange="changeFont()">
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="'Times New Roman', serif">Times New Roman</option>
                    <option value="'Courier New', monospace">Courier New</option>
                    <option value="Georgia, serif">Georgia</option>
                    <option value="Impact, sans-serif">Impact</option>
                    <option value="'Comic Sans MS', cursive">Comic Sans</option>
                </select>
                <div class="slider-control">
                    <label>
                        <span>Font Size</span>
                        <span id="fontSizeValue">20px</span>
                    </label>
                    <input type="range" id="fontSizeSlider" min="10" max="100" value="20" onchange="changeFontSize(this.value)">
                </div>
                <div class="text-controls">
                    <button class="text-control-btn" id="boldBtn" onclick="toggleBold()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>
                            <path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>
                        </svg>
                    </button>
                    <button class="text-control-btn" id="italicBtn" onclick="toggleItalic()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="19" y1="4" x2="10" y2="4"></line>
                            <line x1="14" y1="20" x2="5" y2="20"></line>
                            <line x1="15" y1="4" x2="9" y2="20"></line>
                        </svg>
                    </button>
                    <button class="text-control-btn" id="underlineBtn" onclick="toggleUnderline()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M6 3v18"></path>
                            <path d="M18 3v18"></path>
                            <path d="M6 21h12"></path>
                        </svg>
                    </button>
                    <button class="text-control-btn" onclick="alignText('left')">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="17" y1="10" x2="3" y2="10"></line>
                            <line x1="21" y1="6" x2="3" y2="6"></line>
                            <line x1="21" y1="14" x2="3" y2="14"></line>
                            <line x1="17" y1="18" x2="3" y2="18"></line>
                        </svg>
                    </button>
                    <button class="text-control-btn" onclick="alignText('center')">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="10" x2="6" y2="10"></line>
                            <line x1="21" y1="6" x2="3" y2="6"></line>
                            <line x1="21" y1="14" x2="3" y2="14"></line>
                            <line x1="18" y1="18" x2="6" y2="18"></line>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area">
            <div class="canvas-toolbar">
                <div class="zoom-controls">
                    <button class="icon-btn" onclick="zoomOut()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"></circle>
                            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                            <line x1="8" y1="11" x2="14" y2="11"></line>
                        </svg>
                    </button>
                    <span class="zoom-level" id="zoomPercentage">100%</span>
                    <button class="icon-btn" onclick="zoomIn()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"></circle>
                            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                            <line x1="11" y1="8" x2="11" y2="14"></line>
                            <line x1="8" y1="11" x2="14" y2="11"></line>
                        </svg>
                    </button>
                </div>
                <div class="history-controls">
                    <button class="icon-btn" id="undoBtn" onclick="undo()" disabled>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="1 4 1 10 7 10"></polyline>
                            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                        </svg>
                    </button>
                    <button class="icon-btn" id="redoBtn" onclick="redo()" disabled>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                        </svg>
                    </button>
                </div>
                <button class="icon-btn" onclick="deleteSelected()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        <line x1="10" y1="11" x2="10" y2="17"></line>
                        <line x1="14" y1="11" x2="14" y2="17"></line>
                    </svg>
                </button>
                <button class="icon-btn" onclick="duplicateSelected()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                </button>
                <button class="icon-btn" onclick="bringForward()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="5" y="8" width="14" height="10" rx="2"></rect>
                        <rect x="8" y="5" width="10" height="6" rx="2"></rect>
                    </svg>
                </button>
                <button class="icon-btn" onclick="sendBackward()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="6" y="11" width="12" height="8" rx="2"></rect>
                        <rect x="8" y="5" width="8" height="10" rx="2"></rect>
                    </svg>
                </button>
                <button class="icon-btn" onclick="groupSelected()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="14" y="14" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                    </svg>
                </button>
                <button class="icon-btn" onclick="ungroupSelected()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="3" x2="9" y2="21"></line>
                        <line x1="15" y1="3" x2="15" y2="21"></line>
                        <line x1="3" y1="9" x2="21" y2="9"></line>
                        <line x1="3" y1="15" x2="21" y2="15"></line>
                    </svg>
                </button>
                <button class="icon-btn" onclick="toggleGrid()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 3h7v7H3z"></path>
                        <path d="M14 3h7v7h-7z"></path>
                        <path d="M14 14h7v7h-7z"></path>
                        <path d="M3 14h7v7H3z"></path>
                    </svg>
                </button>
                <button class="icon-btn" onclick="toggleSnap()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 20v-8a8 8 0 0 0-16 0v8"></path>
                        <path d="M4 12h16"></path>
                        <path d="M12 4v16"></path>
                    </svg>
                </button>
            </div>
            <div class="canvas-wrapper">
                <div class="canvas-container">
                    <canvas id="canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Layers Section -->
            <div class="panel-section">
                <h3>Layers</h3>
                <div id="layers-container">
                    <!-- Layers will be dynamically added here -->
                </div>
            </div>

            
            <!-- Templates Section -->
            <div class="panel-section">
                <h3>Templates</h3>
                <div class="figma-credentials">
                    <input type="text" id="figmaClientId" placeholder="Figma Client ID" class="figma-credential-input">
                    <input type="password" id="figmaSecretId" placeholder="Figma Secret ID" class="figma-credential-input">
                    <button id="saveCredentials" class="figma-btn">Save Credentials</button>
                    <button id="loadTemplates" class="figma-btn">Load Templates</button>
                </div>
                <div class="template-grid">
                    <!-- Figma Templates will be loaded here by fetchTemplatePreviews() -->
                </div>
            </div>

            <!-- Canvas Properties -->
            <div class="panel-section">
                <h3>Canvas</h3>
                <div class="form-group">
                    <label>Width (px)</label>
                    <input type="number" id="canvasWidth" class="form-control" value="800" min="100" max="4000" onchange="resizeCanvas()">
                </div>
                <div class="form-group">
                    <label>Height (px)</label>
                    <input type="number" id="canvasHeight" class="form-control" value="600" min="100" max="4000" onchange="resizeCanvas()">
                </div>
                <div class="form-group">
                    <label>Background</label>
                    <input type="color" id="canvasBgColor" class="form-control" value="#FFFFFF" onchange="changeCanvasBackground(this.value)">
                </div>
            </div>

            <!-- Effects Section -->
            <div class="panel-section">
                <h3>Effects</h3>
                <div class="form-group">
                    <label for="filterSelect">Select Filter:</label>
                    <select id="filterSelect" class="form-control" onchange="onFilterSelectChange()">
                        <option value="">-- None --</option>
                        <option value="brightness">Brightness</option>
                        <option value="contrast">Contrast</option>
                        <option value="saturation">Saturation</option>
                        <option value="blur">Blur</option>
                        <option value="noise">Noise</option>
                        <option value="pixelate">Pixelate</option>
                        <option value="grayscale">Grayscale</option>
                        <option value="invert">Invert</option>
                        <option value="sepia">Sepia</option>
                        <option value="sharpen">Sharpen</option>
                        <option value="emboss">Emboss</option>
                        <!-- Add more filter options here -->
                    </select>
                </div>
               
                <!-- Container for dynamic filter controls -->
                <div id="filterControlsContainer" style="margin-top: 15px; border-top: 1px solid var(--border-color); padding-top: 15px;">
                    <!-- Filter-specific controls will be added here by JS -->
                </div>
                <div style="margin-top: 10px; display: flex; gap: 10px;">
                    <button class="btn-primary" style="flex-grow: 1;" onclick="applySelectedFilter()">
                       <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                       Apply
                   </button>
                   <button class="btn-secondary" style="flex-grow: 1;" onclick="removeSelectedFilterType()">
                       <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>
                       Remove
                   </button>
                </div>
                <button class="btn-secondary" style="width: 100%; margin-top: 15px;" onclick="removeFilters()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                       <circle cx="12" cy="12" r="10"></circle>
                       <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>
                    </svg>
                    Remove All Effects
                </button>

            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Name Modal -->
    <div id="nameModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Rename Design</h2>
                <button class="modal-close" onclick="closeModal('nameModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="designName">Design Name</label>
                    <input type="text" id="designName" class="form-control" placeholder="Enter design name">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('nameModal')">Cancel</button>
                <button class="btn-primary" onclick="renameDesign()">Save</button>
            </div>
        </div>
    </div>

    <!-- Grid Modal -->
    <div id="gridModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Add Grid</h2>
                <button class="modal-close" onclick="closeModal('gridModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="gridRows">Rows</label>
                    <input type="number" id="gridRows" class="form-control" value="2" min="1" max="10">
                </div>
                <div class="form-group">
                    <label for="gridColumns">Columns</label>
                    <input type="number" id="gridColumns" class="form-control" value="2" min="1" max="10">
                </div>
                <div class="form-group">
                    <label for="gridGap">Gap (px)</label>
                    <input type="number" id="gridGap" class="form-control" value="10" min="0" max="100">
                </div>
                <div class="form-group">
                    <label for="gridColor">Line Color</label>
                    <input type="color" id="gridColor" class="form-control" value="#cccccc">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('gridModal')">Cancel</button>
                <button class="btn-primary" onclick="createGrid()">Create</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="toast">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
            <polyline points="22 4 12 14.01 9 11.01"></polyline>
        </svg>
        <span id="toastMessage">Operation completed successfully</span>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fabric-pure-browser@5.1.0/dist/fabric.min.js"></script>

    <script>
        // Initialize canvas
        const canvas = new fabric.Canvas('canvas', {
            width: 800,
            height: 600,
            backgroundColor: '#ffffff'
        });

        // Variables for history management
        let canvasHistory = [];
        let currentHistoryIndex = -1;
        let designName = "Untitled Design";
        let isSnapEnabled = false;
        let isGridVisible = false;
        let zoomLevel = 100;
        
        // Initialize the canvas
        function initCanvas() {
            updateCanvasSize();
            setupEventListeners();
            saveToHistory();
            updateLayers();
        }

        // Set up event listeners
        function setupEventListeners() {
            canvas.on('object:modified', function() {
                saveToHistory();
                updateLayers();
            });
            
            canvas.on('object:added', function() {
                saveToHistory();
                updateLayers();
            });
            
            canvas.on('object:removed', function() {
                saveToHistory();
                updateLayers();
            });
            
            canvas.on('selection:created', function() {
                updateControlsForSelection();
            });
            
            canvas.on('selection:updated', function() {
                updateControlsForSelection();
            });
            
            canvas.on('selection:cleared', function() {
                resetControls();
            });
            
            // Handle window resize
            window.addEventListener('resize', function() {
                updateCanvasSize();
            });
        }

        // Update canvas size based on container
        function updateCanvasSize() {
            const width = parseInt(document.getElementById('canvasWidth').value);
            const height = parseInt(document.getElementById('canvasHeight').value);
            
            canvas.setWidth(width);
            canvas.setHeight(height);
            canvas.renderAll();
        }

        // Save current state to history
        function saveToHistory() {
            // Truncate forward history if we're not at the end
            if (currentHistoryIndex < canvasHistory.length - 1) {
                canvasHistory = canvasHistory.slice(0, currentHistoryIndex + 1);
            }
            
            // Save current state
            const json = JSON.stringify(canvas);
            canvasHistory.push(json);
            currentHistoryIndex = canvasHistory.length - 1;
            
            // Update undo/redo buttons
            document.getElementById('undoBtn').disabled = currentHistoryIndex <= 0;
            document.getElementById('redoBtn').disabled = currentHistoryIndex >= canvasHistory.length - 1;
        }

        // Undo action
        function undo() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                loadCanvasState(canvasHistory[currentHistoryIndex]);
                
                document.getElementById('undoBtn').disabled = currentHistoryIndex <= 0;
                document.getElementById('redoBtn').disabled = false;
            }
        }

        // Redo action
        function redo() {
            if (currentHistoryIndex < canvasHistory.length - 1) {
                currentHistoryIndex++;
                loadCanvasState(canvasHistory[currentHistoryIndex]);
                
                document.getElementById('redoBtn').disabled = currentHistoryIndex >= canvasHistory.length - 1;
                document.getElementById('undoBtn').disabled = false;
            }
        }

        // Load canvas state from history
        function loadCanvasState(state) {
            canvas.loadFromJSON(state, function() {
                canvas.renderAll();
                updateLayers();
            });
        }

        // Update controls based on selected object
        function updateControlsForSelection() {
            const activeObject = canvas.getActiveObject();
            
            if (!activeObject) return;
            
            // Update color picker
            if (activeObject.fill && activeObject.fill !== 'transparent') {
                document.getElementById('colorPicker').value = activeObject.fill;
            }
            
            // Update opacity slider
            document.getElementById('opacitySlider').value = activeObject.opacity * 100;
            document.getElementById('opacityValue').innerText = Math.round(activeObject.opacity * 100) + '%';
            
            // Update border width
            const strokeWidth = activeObject.strokeWidth || 0;
            document.getElementById('borderWidthSlider').value = strokeWidth;
            document.getElementById('borderWidthValue').innerText = strokeWidth + 'px';
            
            // Update border color
            if (activeObject.stroke) {
                document.getElementById('borderColorPicker').value = activeObject.stroke;
            }
            
            // Update text controls if it's a text object
            if (activeObject.type === 'text') {
                document.getElementById('fontSizeSlider').value = activeObject.fontSize;
                document.getElementById('fontSizeValue').innerText = activeObject.fontSize + 'px';
                
                // Update font family
                if (activeObject.fontFamily) {
                    const fontSelect = document.getElementById('fontSelect');
                    for (let i = 0; i < fontSelect.options.length; i++) {
                        if (fontSelect.options[i].value.includes(activeObject.fontFamily)) {
                            fontSelect.selectedIndex = i;
                            break;
                        }
                    }
                }
                
                // Update bold button
                const boldBtn = document.getElementById('boldBtn');
                if (activeObject.fontWeight === 'bold') {
                    boldBtn.classList.add('active');
                } else {
                    boldBtn.classList.remove('active');
                }
                
                // Update italic button
                const italicBtn = document.getElementById('italicBtn');
                if (activeObject.fontStyle === 'italic') {
                    italicBtn.classList.add('active');
                } else {
                    italicBtn.classList.remove('active');
                }
                
                // Update underline button
                const underlineBtn = document.getElementById('underlineBtn');
                if (activeObject.underline) {
                    underlineBtn.classList.add('active');
                } else {
                    underlineBtn.classList.remove('active');
                }
            }
        }

        // Reset controls to default state
        function resetControls() {
            // Reset color picker
            document.getElementById('colorPicker').value = '#000000';
            
            // Reset opacity slider
            document.getElementById('opacitySlider').value = 100;
            document.getElementById('opacityValue').innerText = '100%';
            
            // Reset border width
            document.getElementById('borderWidthSlider').value = 1;
            document.getElementById('borderWidthValue').innerText = '1px';
            
            // Reset border color
            document.getElementById('borderColorPicker').value = '#000000';
            
            // Reset text controls
            document.getElementById('fontSizeSlider').value = 20;
            document.getElementById('fontSizeValue').innerText = '20px';
            document.getElementById('fontSelect').selectedIndex = 0;
            
            // Reset text style buttons
            document.getElementById('boldBtn').classList.remove('active');
            document.getElementById('italicBtn').classList.remove('active');
            document.getElementById('underlineBtn').classList.remove('active');
        }

        // Update layers panel
        function updateLayers() {
            const layersContainer = document.getElementById('layers-container');
            layersContainer.innerHTML = '';
            
            // Loop through objects in reverse order so top objects are shown first
            const objects = canvas.getObjects();
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                if (obj === canvas.getActiveObject()) {
                    layerItem.classList.add('active');
                }
                
                // Generate layer name
                let layerName = obj.name || obj.type;
                if (obj.type === 'text') {
                    layerName = obj.text.length > 10 ? obj.text.substring(0, 10) + '...' : obj.text;
                }
                
                layerItem.innerHTML = `
                    <span class="layer-item-name">${layerName}</span>
                    <div class="layer-item-actions">
                        <span class="layer-visibility" onclick="toggleLayerVisibility(${i})">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </span>
                    </div>
                `;
                
                layerItem.addEventListener('click', function() {
                    selectLayerObject(i);
                });
                
                layersContainer.appendChild(layerItem);
            }
        }

        // Select object from layers panel
        function selectLayerObject(index) {
            const objects = canvas.getObjects();
            const obj = objects[index];
            canvas.setActiveObject(obj);
            canvas.renderAll();
            updateControlsForSelection();
        }

        // Toggle layer visibility
        function toggleLayerVisibility(index) {
            const objects = canvas.getObjects();
            const obj = objects[index];
            obj.visible = !obj.visible;
            canvas.renderAll();
            updateLayers();
        }

        // Show modal
        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
        }

        // Close modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Show rename modal
        function showNameModal() {
            document.getElementById('designName').value = designName;
            showModal('nameModal');
        }

        // Show grid modal
        function showGridModal() {
            showModal('gridModal');
        }

        // Rename design
        function renameDesign() {
            const newName = document.getElementById('designName').value.trim();
            if (newName) {
                designName = newName;
                document.querySelector('.btn-secondary').innerText = designName;
                showToast('Design renamed to ' + designName);
            }
            closeModal('nameModal');
        }

        // Show toast message
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            document.getElementById('toastMessage').innerText = message;
            
            // Set toast type
            toast.className = 'toast';
            if (type === 'success') {
                toast.classList.add('toast-success');
            } else if (type === 'error') {
                toast.classList.add('toast-error');
            }
            
            // Show toast
            toast.classList.add('show');
            
            // Hide toast after 3 seconds
            setTimeout(function() {
                toast.classList.remove('show');
            }, 3000);
        }

        // Add rectangle
        function addRectangle() {
            const rect = new fabric.Rect({
                left: 100,
                top: 100,
                fill: document.getElementById('colorPicker').value,
                width: 150,
                height: 100,
                strokeWidth: 0
            });
            canvas.add(rect);
            canvas.setActiveObject(rect);
        }

        // Add circle
        function addCircle() {
            const circle = new fabric.Circle({
                left: 100,
                top: 100,
                fill: document.getElementById('colorPicker').value,
                radius: 50,
                strokeWidth: 0
            });
            canvas.add(circle);
            canvas.setActiveObject(circle);
        }

        // Add triangle
        function addTriangle() {
            const triangle = new fabric.Triangle({
                left: 100,
                top: 100,
                fill: document.getElementById('colorPicker').value,
                width: 100,
                height: 100,
                strokeWidth: 0
            });
            canvas.add(triangle);
            canvas.setActiveObject(triangle);
        }

        // Add star
        function addStar() {
            const points = [
                {x: 0, y: -50},
                {x: 19.1, y: -15.5},
                {x: 58.8, y: -15.5},
                {x: 19.1, y: 6.2},
                {x: 38.2, y: 40.5},
                {x: 0, y: 19.1},
                {x: -38.2, y: 40.5},
                {x: -19.1, y: 6.2},
                {x: -58.8, y: -15.5},
                {x: -19.1, y: -15.5}
            ];
            
            const star = new fabric.Polygon(points, {
                left: 100,
                top: 100,
                fill: document.getElementById('colorPicker').value,
                strokeWidth: 0
            });
            canvas.add(star);
            canvas.setActiveObject(star);
        }

        // Store Figma credentials
        let figmaCredentials = {
           clientId: '',
           secretId: ''
        };

        function saveCredentials() {
            const clientId = document.getElementById('figmaClientId').value.trim();
    const secretId = document.getElementById('figmaSecretId').value.trim();
    
    if (!clientId || !secretId) {
        showToast("Please enter both Client ID and Secret ID", "error");
        return;
    }
    
    figmaCredentials = { clientId, secretId };
    localStorage.setItem('figmaCredentials', JSON.stringify(figmaCredentials));
    showToast("Figma credentials saved", "success");
}
        
    // NEW: Function to fetch template previews from YOUR backend
    async function fetchTemplatePreviews() {
    const templatesContainer = document.querySelector('.template-grid');
    templatesContainer.innerHTML = '<p>Loading Figma Templates...</p>'; // Loading state
    
    if (!figmaCredentials.clientId || !figmaCredentials.secretId) {
        templatesContainer.innerHTML = '<p>Please enter your Figma Client ID and Secret ID to load templates.</p>';
        return;
    }

    try {
        // Pass credentials to your backend
        const response = await fetch('/api/figma-templates/previews', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                clientId: figmaCredentials.clientId,
                secretId: figmaCredentials.secretId
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const templates = await response.json();

        templatesContainer.innerHTML = ''; // Clear loading message
        if (!templates || templates.length === 0) {
            templatesContainer.innerHTML = '<p>No Figma templates found.</p>';
            return;
        }

        templates.forEach(template => {
            const templateItem = document.createElement('div');
            templateItem.className = 'template-item figma-template';
            templateItem.style.cursor = 'pointer';
            templateItem.innerHTML = `
                <img src="${template.previewUrl}" alt="${template.name || 'Figma Template'}" style="width: 100%; height: auto; display: block; border: 1px solid var(--border-color);">
                <span style="font-size: 0.8em; display: block; text-align: center; padding: 4px 0;">${template.name || 'Template'}</span>
            `;
            templateItem.dataset.fileKey = template.fileKey;
            templateItem.dataset.nodeId = template.nodeId;

            templateItem.onclick = () => loadFigmaTemplate(template.fileKey, template.nodeId);

            templatesContainer.appendChild(templateItem);
        });

    } catch (error) {
        console.error("Error fetching Figma template previews:", error);
        templatesContainer.innerHTML = '<p>Error loading templates. Check your credentials or backend connection.</p>';
        showToast("Could not load Figma templates.", "error");
    }
}

// Modified function to load a specific Figma template via YOUR backend with credentials
async function loadFigmaTemplate(fileKey, nodeId) {
    if (!fileKey || !nodeId) {
        console.error("Missing Figma fileKey or nodeId");
        return;
    }

    showToast("Loading Figma template...", "info");

    try {
        // Pass credentials along with the request
        const response = await fetch(`/api/figma-templates/load/${fileKey}/${nodeId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                clientId: figmaCredentials.clientId,
                secretId: figmaCredentials.secretId
            })
        });

        if (!response.ok) {
            const errorData = await response.text();
            console.error("Backend error response:", errorData);
            throw new Error(`Failed to load template data. Status: ${response.status}`);
        }

        const fabricJson = await response.json();

        if (!fabricJson || !fabricJson.objects) {
            throw new Error("Received invalid data format from backend.");
        }

        // Prepare Canvas
        canvas.clear();
        removeGeneratedGrid();
        removeGrid();
        canvasHistory = [];
        canvas.isDrawingMode = false;
        currentDrawingTool = null;
        document.getElementById('pencilBtn')?.classList.remove('active');
        document.getElementById('eraserBtn')?.classList.remove('active');
        resetControls();

        // Load Data into Canvas
        const bgColor = fabricJson.background || '#ffffff';
        canvas.setBackgroundColor(bgColor, () => {
            canvas.loadFromJSON(fabricJson, () => {
                const targetWidth = fabricJson.width || canvas.width;
                const targetHeight = fabricJson.height || canvas.height;
                resizeCanvasInternal(targetWidth, targetHeight);

                canvas.renderAll();
                saveToHistory();
                updateLayers();
                showToast("Figma template loaded successfully.", "success");
            });
        });

    } catch (error) {
        console.error("Error loading Figma template:", error);
        showToast(`Error: ${error.message}`, "error");
    }
}

        // Add text
        function addText() {
            const text = new fabric.Text('Double click to edit', {
                left: 100,
                top: 100,
                fontSize: 20,
                fontFamily: document.getElementById('fontSelect').value,
                fill: document.getElementById('colorPicker').value
            });
            canvas.add(text);
            canvas.setActiveObject(text);
        }

        // Add line
        function addLine() {
            const line = new fabric.Line([0, 0, 100, 0], {
                left: 100,
                top: 100,
                stroke: document.getElementById('colorPicker').value,
                strokeWidth: 3
            });
            canvas.add(line);
            canvas.setActiveObject(line);
        }

        // Add arrow
        function addArrow() {
            const line = new fabric.Line([0, 0, 100, 0], {
                left: 100,
                top: 100,
                stroke: document.getElementById('colorPicker').value,
                strokeWidth: 3
            });
            
            const triangle = new fabric.Triangle({
                left: line.left + line.width - 5, // Position at the end of the line's default position
                top: line.top - 5,             // Center vertically relative to the line
                angle: 90,                     // Point the triangle to the right
                width: 10,
                height: 15,
                fill: document.getElementById('colorPicker').value,
                stroke: document.getElementById('colorPicker').value, // Match fill for arrowhead
                strokeWidth: 1 // Give arrowhead a thin border
            });

            const arrow = new fabric.Group([line, triangle], {
                left: 100,
                top: 100,
                // Custom properties to identify arrow components if needed later
                _line: line,
                _head: triangle,
                // Set origin to the start of the line for more intuitive rotation/scaling
                originX: 'left',
                originY: 'center',
                // Lock non-uniform scaling initially if desired
                // lockUniScaling: true
                // Let's keep rotation unlocked by default for arrows
            });


            // --- Arrow Head Update Logic ---
            // More robust calculation needed for angled lines
            function updateArrowHeadPosition(group) {
                const line = group._line;
                const head = group._head;

                // Get line end point in canvas coordinates
                const lineTransform = line.calcTransformMatrix();
                const startPoint = fabric.util.transformPoint({ x: line.x1, y: line.y1 }, lineTransform);
                const endPoint = fabric.util.transformPoint({ x: line.x2, y: line.y2 }, lineTransform);

                 // Calculate angle of the line
                const angleRad = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
                const angleDeg = fabric.util.radiansToDegrees(angleRad);

                // Position the head at the end point
                 // Adjust slightly back along the line based on head size for better visual connection
                const headOffset = head.height / 2; // Approximate offset based on head height when rotated
                const newHeadX = endPoint.x - headOffset * Math.cos(angleRad);
                const newHeadY = endPoint.y - headOffset * Math.sin(angleRad);

                 // Calculate transform needed to move the group's origin to the line's endpoint
                 const groupTransform = group.calcTransformMatrix();
                 const inverseGroupTransform = fabric.util.invertTransform(groupTransform);

                 // Transform the desired head position into the group's local coordinate system
                 const desiredLocalPoint = fabric.util.transformPoint({x: newHeadX, y: newHeadY}, inverseGroupTransform);

                head.set({
                    left: desiredLocalPoint.x,
                    top: desiredLocalPoint.y,
                    angle: angleDeg + 90 // Arrowhead angle is perpendicular to line + 90 deg
                });
            }


            // Update arrow head on moving, scaling, rotating
            arrow.on('moving', function() { updateArrowHeadPosition(this); });
            arrow.on('scaling', function() { updateArrowHeadPosition(this); });
            arrow.on('rotating', function() { updateArrowHeadPosition(this); });
            // Also update when line points are modified (if that becomes possible)

            // Initial positioning
            updateArrowHeadPosition(arrow);


            canvas.add(arrow);
            canvas.setActiveObject(arrow);
        }

           // Upload Image
           function uploadImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(f) {
                    const data = f.target.result;
                    fabric.Image.fromURL(data, function(img) {
                        // Scale image to fit canvas if it's too large
                        const maxDim = Math.min(canvas.width * 0.8, canvas.height * 0.8);
                        if (img.width > maxDim || img.height > maxDim) {
                            img.scaleToWidth(maxDim);
                             if (img.getScaledHeight() > maxDim) {
                                img.scaleToHeight(maxDim);
                            }
                        }

                        img.set({
                            left: canvas.width / 2,
                            top: canvas.height / 2,
                            originX: 'center',
                            originY: 'center',
                             // IMPORTANT: Disable caching temporarily before filter for some potential issues
                             // objectCaching: false,
                        });
                        canvas.add(img);
                        canvas.setActiveObject(img);
                        canvas.renderAll();
                        saveToHistory(); // Save after adding
                    });
                };
                reader.readAsDataURL(file);
            }
            input.click();
        }

        // Create Grid (from Modal)
        function createGrid() {
            const rows = parseInt(document.getElementById('gridRows').value);
            const cols = parseInt(document.getElementById('gridColumns').value);
            const gap = parseInt(document.getElementById('gridGap').value);
            const color = document.getElementById('gridColor').value;
            const canvasWidth = canvas.getWidth();
            const canvasHeight = canvas.getHeight();

            const cellWidth = (canvasWidth - (cols + 1) * gap) / cols;
            const cellHeight = (canvasHeight - (rows + 1) * gap) / rows;

            if (cellWidth <= 0 || cellHeight <= 0) {
                showToast("Grid dimensions result in negative cell size. Adjust rows/cols/gap.", "error");
                return;
            }

            const gridGroup = [];

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const rect = new fabric.Rect({
                        left: gap + c * (cellWidth + gap),
                        top: gap + r * (cellHeight + gap),
                        width: cellWidth,
                        height: cellHeight,
                        fill: 'transparent',
                        stroke: color,
                        strokeWidth: 1,
                        selectable: false, // Make grid lines unselectable
                        evented: false     // Make grid lines not interactable
                    });
                    gridGroup.push(rect);
                }
            }

            const group = new fabric.Group(gridGroup, {
                left: 0,
                top: 0,
                selectable: false,
                evented: false,
                name: 'grid_layout' // Identify the grid group
            });

            // Remove any existing grid before adding a new one
            removeGeneratedGrid(); // Use a dedicated function

            canvas.add(group);
            canvas.sendToBack(group); // Send grid behind other elements
            closeModal('gridModal');
            showToast(`Grid (${rows}x${cols}) created.`);
            saveToHistory(); // Save grid addition
        }

        function removeGeneratedGrid() {
             canvas.getObjects().forEach(obj => {
                if (obj.name === 'grid_layout') {
                    canvas.remove(obj);
                }
            });
        }

        // --- Drawing Mode ---
        let currentDrawingTool = null; // 'pencil', 'eraser', or null
        function toggleDrawingMode(tool) {
            const currentlyActive = currentDrawingTool === tool;

            // --- Turn OFF logic (consistent for both tools) ---
            if (currentlyActive) {
                canvas.isDrawingMode = false;
                currentDrawingTool = null;
                document.getElementById(`${tool}Btn`)?.classList.remove('active');
                showToast(`${tool.charAt(0).toUpperCase() + tool.slice(1)} tool deactivated.`);
                // Re-enable selection and interaction for ALL objects
                 canvas.selection = true;
                 canvas.getObjects().forEach(o => o.set({evented: true})); // Make sure everything is evented again
                 canvas.renderAll(); // Rerender after making objects evented
                 return; // Exit after turning off
            }

            // --- Turn ON logic ---

            // Deactivate previously active tool button if different
            if (currentDrawingTool && currentDrawingTool !== tool) {
                document.getElementById(`${currentDrawingTool}Btn`)?.classList.remove('active');
            }

            canvas.isDrawingMode = true;
            canvas.discardActiveObject(); // Deselect any active object
            canvas.selection = false; // Disable box selection

            currentDrawingTool = tool;
            document.getElementById(`${tool}Btn`)?.classList.add('active');

            if (tool === 'pencil') {
                // Pencil: Make objects underneath NON-interactive
                 canvas.getObjects().forEach(o => o.set({evented: false}));
                // Configure Pencil Brush
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.color = document.getElementById('colorPicker').value;
                canvas.freeDrawingBrush.width = parseInt(document.getElementById('borderWidthSlider').value) || 1;
                 showToast(`Pencil tool activated. Color: ${canvas.freeDrawingBrush.color}, Width: ${canvas.freeDrawingBrush.width}`);

            } else if (tool === 'eraser') {
                // Eraser: Objects underneath MUST BE interactive
                 canvas.getObjects().forEach(o => o.set({evented: true})); // Ensure objects ARE evented

                if (typeof fabric.EraserBrush === 'undefined') {
                     showToast("Eraser tool requires Fabric.js v5 or higher.", "error");
                     // Reset state if eraser unavailable
                     canvas.isDrawingMode = false;
                     currentDrawingTool = null;
                     document.getElementById(`${tool}Btn`)?.classList.remove('active');
                     canvas.selection = true; // Re-enable selection
                     return;
                }
                // Configure Eraser Brush
                canvas.freeDrawingBrush = new fabric.EraserBrush(canvas);
                // Make eraser width potentially larger by default
                canvas.freeDrawingBrush.width = parseInt(document.getElementById('borderWidthSlider').value) || 20;
                 showToast(`Eraser tool activated. Width: ${canvas.freeDrawingBrush.width}`);
            }
             canvas.renderAll(); // Render after changing evented status
        }

         // Update brush properties when controls change AND in drawing mode
        function updateBrushProperties() {
            if (canvas.isDrawingMode && currentDrawingTool && canvas.freeDrawingBrush) {
                 if (currentDrawingTool === 'pencil') {
                    canvas.freeDrawingBrush.color = document.getElementById('colorPicker').value;
                    canvas.freeDrawingBrush.width = parseInt(document.getElementById('borderWidthSlider').value) || 1;
                 } else if (currentDrawingTool === 'eraser') {
                     canvas.freeDrawingBrush.width = parseInt(document.getElementById('borderWidthSlider').value) || 10;
                 }
            }
        }


        // Set color for selected object(s) OR pencil brush
        function setColor(color) {
            document.getElementById('colorPicker').value = color; // Sync custom picker

            if (canvas.isDrawingMode && currentDrawingTool === 'pencil') {
                canvas.freeDrawingBrush.color = color;
                 showToast(`Pencil color set to ${color}`);
            } else {
                const activeObject = canvas.getActiveObject();
                if (!activeObject) return;

                // --- REMOVED THE GRADIENT CLEARING LOGIC FROM HERE ---
                // We will only set solid color. Applying gradient is a separate action.
                // Resetting styles is also separate.

                const applySolidColor = (obj) => {
                    // Only apply solid color if the fill isn't already the same solid color
                    if (obj.fill !== color || obj.fill instanceof fabric.Gradient) {
                         obj.set('fill', color);
                         // Clear any stored original fill if we explicitly set a solid color
                         if (obj._originalFill) {
                             obj._originalFill = null;
                         }
                    }
                };

                if (activeObject.type === 'activeSelection') {
                    activeObject.forEachObject(applySolidColor);
                } else {
                    applySolidColor(activeObject);
                }
                canvas.renderAll();
                saveToHistory();
                // updateControlsForSelection will reflect the new solid color
                updateControlsForSelection();
            }
        }


        // Apply Gradient Function
        function applyGradient() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                 showToast("Select an object or group to apply gradient.", "error");
                return;
            }

            // Deactivate drawing mode if active
            if (canvas.isDrawingMode) {
                toggleDrawingMode(currentDrawingTool); // Turn off current tool
            }

            const type = document.getElementById('gradientType').value;
            const color1 = document.getElementById('gradientColor1').value;
            const color2 = document.getElementById('gradientColor2').value;

             const applyToObject = (obj) => {
                 // Skip if object doesn't support fill (e.g., potentially some groups)
                 if (!obj.setGradient) {
                     console.warn("Object type doesn't support setGradient:", obj.type);
                     return;
                 }

                 // Store original fill if it's not already a gradient and not already stored
                 if (!(obj.fill instanceof fabric.Gradient) && !obj._originalFill) {
                    obj._originalFill = obj.fill;
                 }

                 let coords = {};
                 // Use getScaledWidth/Height for accurate current dimensions
                 const objWidth = obj.getScaledWidth();
                 const objHeight = obj.getScaledHeight();

                 // Define gradient coordinates relative to object bounding box
                 if (type === 'linear') {
                     coords = { x1: 0, y1: 0, x2: objWidth, y2: 0 }; // Default LTR
                 } else if (type === 'radial') {
                     coords = {
                         x1: objWidth / 2, y1: objHeight / 2, // Center start
                         x2: objWidth / 2, y2: objHeight / 2, // Center end
                         r1: 0, // Inner radius (center)
                         r2: Math.min(objWidth, objHeight) / 2 // Outer radius based on smaller dimension
                     };
                 } else {
                     console.error("Unknown gradient type:", type);
                     return; // Don't proceed if type is invalid
                 }

                 try {
                     obj.setGradient('fill', {
                        type: type,
                        coords: coords, // Use calculated coords
                        colorStops: [
                            { offset: 0, color: color1 },
                            { offset: 1, color: color2 }
                        ]
                     });

                     // --- DEBUGGING ---
                     console.log(`Applied ${type} gradient to ${obj.type}. Fill is now:`, obj.fill);
                     if (obj.fill instanceof fabric.Gradient) {
                         console.log("Gradient Coords:", obj.fill.coords);
                         console.log("Gradient Stops:", obj.fill.colorStops);
                     }
                     // --- END DEBUGGING ---

                     // --- Force Recalculation ---
                     obj.setCoords(); // Recalculate object controls box & coordinates
                     obj.dirty = true; // Mark object as needing redraw

                 } catch (error) {
                     console.error("Error applying gradient:", error);
                     showToast("Failed to apply gradient.", "error");
                      // Restore original fill if error occurs? Optional.
                     // if (obj._originalFill) {
                     //     obj.set('fill', obj._originalFill);
                     //     obj._originalFill = null;
                     // }
                 }
             };

             if (activeObject.type === 'activeSelection') {
                activeObject.forEachObject(applyToObject);
            } else {
                applyToObject(activeObject);
            }

            canvas.renderAll(); // Request render after all objects potentially modified
            saveToHistory();
            showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} gradient applied.`);
            updateControlsForSelection();
        }


        // Change opacity
        function changeOpacity(value) {
            const opacity = parseInt(value) / 100;
            document.getElementById('opacityValue').innerText = value + '%';

            const activeObject = canvas.getActiveObject();
            if (!activeObject) return;

            if (activeObject.type === 'activeSelection') {
                activeObject.forEachObject(function(obj) {
                    obj.set('opacity', opacity);
                });
            } else {
                activeObject.set('opacity', opacity);
            }
            canvas.renderAll();
            saveToHistory();
        }

        // Change border width OR drawing brush width
        function changeBorderWidth(value) {
            const width = parseInt(value);
            document.getElementById('borderWidthValue').innerText = width + 'px';

            if (canvas.isDrawingMode && currentDrawingTool) {
                 if (currentDrawingTool === 'pencil' || currentDrawingTool === 'eraser') {
                     canvas.freeDrawingBrush.width = width > 0 ? width : 1; // Ensure minimum width of 1
                     showToast(`${currentDrawingTool} width set to ${canvas.freeDrawingBrush.width}px`);
                 }
                 // No history save needed for brush change
            } else {
                 const activeObject = canvas.getActiveObject();
                if (!activeObject) return;

                if (activeObject.type === 'activeSelection') {
                    activeObject.forEachObject(function(obj) {
                         // Don't add border if it was 0 unless color is also set
                        if (width > 0 || obj.stroke) {
                            obj.set('strokeWidth', width);
                            // Ensure a default border color if width > 0 and no color exists
                            if (width > 0 && !obj.stroke) {
                                obj.set('stroke', document.getElementById('borderColorPicker').value);
                            }
                        }
                        // Remove border if width is 0
                        if (width === 0) {
                            obj.set('strokeWidth', 0);
                            // Optionally remove stroke color too when width is 0
                            // obj.set('stroke', null);
                        }
                    });
                } else {
                    if (width > 0 || activeObject.stroke) {
                        activeObject.set('strokeWidth', width);
                        if (width > 0 && !activeObject.stroke) {
                            activeObject.set('stroke', document.getElementById('borderColorPicker').value);
                        }
                    }
                    if (width === 0) {
                        activeObject.set('strokeWidth', 0);
                         // activeObject.set('stroke', null);
                    }
                }
                canvas.renderAll();
                saveToHistory();
                updateControlsForSelection(); // Ensure border color picker updates if needed
            }
        }

        // Change border color
        function changeBorderColor(color) {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) return;

             // Ensure border width is at least 1 when setting color
            const currentWidth = parseInt(document.getElementById('borderWidthSlider').value);
            const borderWidthToSet = currentWidth === 0 ? 1 : currentWidth;

            if (currentWidth === 0 && !canvas.isDrawingMode) { // Don't change slider if in drawing mode
                document.getElementById('borderWidthSlider').value = 1;
                document.getElementById('borderWidthValue').innerText = '1px';
            }


            if (activeObject.type === 'activeSelection') {
                activeObject.forEachObject(function(obj) {
                    obj.set('stroke', color);
                    if (obj.strokeWidth === 0) {
                        obj.set('strokeWidth', borderWidthToSet);
                    }
                });
            } else {
                activeObject.set('stroke', color);
                 if (activeObject.strokeWidth === 0) {
                        activeObject.set('strokeWidth', borderWidthToSet);
                    }
            }
            canvas.renderAll();
            saveToHistory();
        }

        // Add shadow
        function addShadow() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                showToast("Select an object to add shadow.", "error");
                return;
            }

            const shadowOptions = {
                color: 'rgba(0,0,0,0.5)',
                blur: 10,
                offsetX: 5,
                offsetY: 5
            };

            if (activeObject.type === 'activeSelection') {
                activeObject.forEachObject(function(obj) {
                    obj.set('shadow', new fabric.Shadow(shadowOptions));
                });
            } else {
                activeObject.set('shadow', new fabric.Shadow(shadowOptions));
            }
            canvas.renderAll();
            saveToHistory();
            showToast("Shadow added.");
        }

        // Remove styles (opacity, border, shadow, gradient)
        function removeStyles() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                 showToast("Select an object to reset styles.", "error");
                return;
            }

            const resetStyleProps = (obj) => {
                 obj.set({
                    opacity: 1,
                    stroke: null,
                    strokeWidth: 0,
                    shadow: null
                 });
                 // Restore original fill if it was overridden by gradient
                 if (obj._originalFill) {
                    obj.set('fill', obj._originalFill);
                    obj._originalFill = null; // Clear the stored original
                 } else if (obj.fill instanceof fabric.Gradient){
                     // If no original fill stored, maybe revert to default color?
                     obj.set('fill', '#000000'); // Or another default
                 }
            };


            if (activeObject.type === 'activeSelection') {
                activeObject.forEachObject(resetStyleProps);
            } else {
                resetStyleProps(activeObject);
            }
            canvas.renderAll();
            resetControls(); // Reset sidebar controls as well
            saveToHistory();
            showToast("Styles reset.");
        }


        // --- Text Controls ---

         // Add text (Using IText for editing)
        function addText() {
            // Deactivate drawing mode if active
            if (canvas.isDrawingMode) {
                toggleDrawingMode(currentDrawingTool); // Turn off current tool
            }
            const text = new fabric.IText('Double click to edit', { // Use IText
                left: 100,
                top: 100,
                fontSize: 20, // Default font size
                fontFamily: document.getElementById('fontSelect').value,
                fill: document.getElementById('colorPicker').value,
                 padding: 5 // Add some padding for easier selection
            });
            canvas.add(text);
            canvas.setActiveObject(text);
            canvas.renderAll();
             // History saved by object:added event
        }


        function changeFont() {
            const font = document.getElementById('fontSelect').value;
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'textbox')) {
                activeObject.set('fontFamily', font);
                canvas.renderAll();
                saveToHistory();
            } else if (activeObject && activeObject.type === 'activeSelection') {
                 activeObject.forEachObject(function(obj) {
                    if (obj.type === 'i-text' || obj.type === 'textbox') {
                        obj.set('fontFamily', font);
                    }
                });
                canvas.renderAll();
                saveToHistory();
            }
        }

        function changeFontSize(value) {
            const size = parseInt(value);
            document.getElementById('fontSizeValue').innerText = size + 'px';
            const activeObject = canvas.getActiveObject();

             if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'textbox')) {
                activeObject.set('fontSize', size);
                canvas.renderAll();
                saveToHistory();
            } else if (activeObject && activeObject.type === 'activeSelection') {
                 activeObject.forEachObject(function(obj) {
                    if (obj.type === 'i-text' || obj.type === 'textbox') {
                         obj.set('fontSize', size);
                    }
                });
                canvas.renderAll();
                saveToHistory();
            }
        }

        function toggleStyle(styleName, valueOn, valueOff, buttonId) {
             const activeObject = canvas.getActiveObject();
             const btn = document.getElementById(buttonId);
             let isActive = false;

             if (!activeObject) return;

             function applyStyle(obj) {
                if (obj.type !== 'i-text' && obj.type !== 'textbox') return; // Only apply to text

                 const currentVal = obj.get(styleName);
                 const isSet = (styleName === 'fontWeight' && currentVal === valueOn) ||
                               (styleName === 'fontStyle' && currentVal === valueOn) ||
                               (styleName === 'underline' && currentVal === valueOn); // Check underline specifically

                 if (isSet) {
                     obj.set(styleName, valueOff);
                     isActive = false;
                 } else {
                     obj.set(styleName, valueOn);
                     isActive = true;
                 }
             }

             if (activeObject.type === 'activeSelection') {
                 let firstObjState = null; // Determine initial state from first text object
                 activeObject.forEachObject(function(obj) {
                    if (obj.type === 'i-text' || obj.type === 'textbox') {
                        if(firstObjState === null) {
                            const currentVal = obj.get(styleName);
                            firstObjState = (styleName === 'fontWeight' && currentVal === valueOn) ||
                                            (styleName === 'fontStyle' && currentVal === valueOn) ||
                                            (styleName === 'underline' && currentVal === valueOn);
                            isActive = !firstObjState; // Toggle based on the first object's state
                        }
                        obj.set(styleName, isActive ? valueOn : valueOff);
                    }
                });

             } else if (activeObject.type === 'i-text' || activeObject.type === 'textbox') {
                 applyStyle(activeObject);
             } else {
                 return; // Not a text object or group containing text
             }

             // Update button state
             if (btn) {
                 if (isActive) {
                     btn.classList.add('active');
                 } else {
                     btn.classList.remove('active');
                 }
             }

             canvas.renderAll();
             saveToHistory();
        }

        function toggleBold() {
            toggleStyle('fontWeight', 'bold', 'normal', 'boldBtn');
        }

        function toggleItalic() {
            toggleStyle('fontStyle', 'italic', 'normal', 'italicBtn');
        }

        function toggleUnderline() {
             toggleStyle('underline', true, false, 'underlineBtn');
        }

        function alignText(align) {
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'textbox')) {
                activeObject.set('textAlign', align);
                canvas.renderAll();
                saveToHistory();
            } else if (activeObject && activeObject.type === 'activeSelection') {
                 activeObject.forEachObject(function(obj) {
                    if (obj.type === 'i-text' || obj.type === 'textbox') {
                        obj.set('textAlign', align);
                    }
                });
                canvas.renderAll();
                saveToHistory();
            }
        }

        // --- Canvas Toolbar Actions --- (Zoom, Delete, Duplicate, Layer Order, Grouping - Mostly unchanged)

        function zoom(factor) {
            const newZoom = canvas.getZoom() * factor;
            const clampedZoom = Math.max(0.1, Math.min(newZoom, 10)); // Limit zoom 10% - 1000%

             // Zoom relative to center
             canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), clampedZoom);

            // // Alternative: Zoom relative to mouse pointer (more complex to implement well)
            // const point = new fabric.Point(canvas.width / 2, canvas.height / 2); // Default center
            // canvas.zoomToPoint(point, clampedZoom);


            zoomLevel = Math.round(clampedZoom * 100);
            document.getElementById('zoomPercentage').innerText = zoomLevel + '%';
            canvas.renderAll();
            // Zooming doesn't usually go into history
            // Re-draw grid if visible, as zoom changes its appearance relative to canvas
             if (isGridVisible) { drawGrid(); }
        }

        function zoomIn() {
            zoom(1.1); // Zoom in by 10%
        }

        function zoomOut() {
            zoom(0.9); // Zoom out by 10%
        }

        function deleteSelected() {
             // Deactivate drawing mode if active
            if (canvas.isDrawingMode) {
                toggleDrawingMode(currentDrawingTool); // Turn off current tool
            }
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                showToast("Select an object or group to delete.", "error");
                return;
            }

            if (activeObject.type === 'activeSelection') {
                activeObject.forEachObject(function(obj) {
                    canvas.remove(obj);
                });
            } else {
                canvas.remove(activeObject);
            }
            canvas.discardActiveObject();
            canvas.renderAll();
            // saveToHistory() is called automatically by object:removed event
        }

        function duplicateSelected() {
             // Deactivate drawing mode if active
            if (canvas.isDrawingMode) {
                toggleDrawingMode(currentDrawingTool); // Turn off current tool
            }
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                showToast("Select an object or group to duplicate.", "error");
                return;
            }

            activeObject.clone(function(clonedObj) {
                canvas.discardActiveObject(); // Deselect original first

                clonedObj.set({
                    left: activeObject.left + 20,
                    top: activeObject.top + 20,
                    evented: true, // Ensure cloned object is interactive
                    name: activeObject.name ? `${activeObject.name}_copy` : '' // Optional: give copy a name
                });

                if (clonedObj.type === 'activeSelection') {
                    // active selection needs to be recreated from cloned objects
                    clonedObj.canvas = canvas;
                    clonedObj.forEachObject(function(obj) {
                        canvas.add(obj);
                    });
                    // select the newly added objects
                    clonedObj.setCoords();
                } else {
                    canvas.add(clonedObj);
                }
                canvas.setActiveObject(clonedObj); // Select the clone
                canvas.requestRenderAll();
            }, ['_originalFill']); // Include custom properties if needed when cloning
             // saveToHistory() is called automatically by object:added event
        }

        function bringForward() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.bringForward(activeObject);
                canvas.renderAll();
                saveToHistory();
                updateLayers();
            }
        }

        function sendBackward() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                // Avoid sending behind grid layout/drawing if they exist
                const gridLayout = canvas.getObjects().find(o => o.name === 'grid_layout');
                const gridDrawing = canvas.getObjects().find(o => o.name === 'grid_drawing');
                const lowestIndex = Math.max(
                    gridLayout ? canvas.getObjects().indexOf(gridLayout) : -1,
                    gridDrawing ? canvas.getObjects().indexOf(gridDrawing) : -1
                );

                const currentIndex = canvas.getObjects().indexOf(activeObject);
                 if (currentIndex > lowestIndex + 1) { // Only send back if not already right above grid
                     canvas.sendBackwards(activeObject);
                     canvas.renderAll();
                     saveToHistory();
                     updateLayers();
                 } else {
                     showToast("Cannot send further back.");
                 }

            }
        }

        function groupSelected() {
            if (!canvas.getActiveObject() || canvas.getActiveObject().type !== 'activeSelection') {
                showToast("Select multiple objects to group.", "error");
                return;
            }
            // Deactivate drawing mode if active
            if (canvas.isDrawingMode) {
                toggleDrawingMode(currentDrawingTool); // Turn off current tool
            }
            const group = canvas.getActiveObject().toGroup();
            canvas.requestRenderAll();
            showToast("Objects grouped.");
            saveToHistory(); // Grouping modifies the canvas state
            updateLayers();
        }

        function ungroupSelected() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || activeObject.type !== 'group') {
                showToast("Select a group to ungroup.", "error");
                return;
            }
             // Deactivate drawing mode if active
            if (canvas.isDrawingMode) {
                toggleDrawingMode(currentDrawingTool); // Turn off current tool
            }
            activeObject.toActiveSelection();
            canvas.requestRenderAll();
            showToast("Group ungrouped.");
            saveToHistory(); // Ungrouping modifies the canvas state
            updateLayers();
        }

        // --- Grid & Snapping --- (toggleGrid, drawGrid, removeGrid, toggleSnap - Largely unchanged)
        let gridLinesGroup = null; // To hold grid lines if drawn manually
        const gridSnapSize = 30; // Define snap size

        function toggleGrid() {
            isGridVisible = !isGridVisible;
            if (isGridVisible) {
                drawGrid(gridSnapSize); // Use snap size for grid lines
                showToast("Grid enabled.");
            } else {
                removeGrid();
                showToast("Grid disabled.");
            }
        }

        function drawGrid(size = 30, color = '#ddd') {
            removeGrid(); // Clear existing grid first
            const width = canvas.getWidth();
            const height = canvas.getHeight();
            const lines = [];
            const zoom = canvas.getZoom();

             // Adjust grid density based on zoom? Optional, can be complex
             // const effectiveSize = size * Math.max(1, Math.floor(1/zoom)); // Example: less lines when zoomed out

            // Vertical lines
            for (let i = 0; i < (width / size); i++) {
                lines.push(new fabric.Line([i * size, 0, i * size, height], { stroke: color, selectable: false, evented: false, name: 'grid_line' }));
            }
            // Horizontal lines
            for (let i = 0; i < (height / size); i++) {
                 lines.push(new fabric.Line([0, i * size, width, i * size], { stroke: color, selectable: false, evented: false, name: 'grid_line' }));
            }

            gridLinesGroup = new fabric.Group(lines, {
                left: 0, top: 0, selectable: false, evented: false, name: 'grid_drawing', // Use consistent name
                // Ensure grid lines scale with zoom visually, but snapping logic uses original size
                 originX: 'left', originY: 'top'
            });
            canvas.add(gridLinesGroup);
            canvas.sendToBack(gridLinesGroup);
            canvas.renderAll(); // Render after adding grid
        }

        function removeGrid() {
             canvas.getObjects().forEach(obj => {
                if (obj.name === 'grid_drawing') { // Remove the drawn grid group
                    canvas.remove(obj);
                }
            });
            gridLinesGroup = null; // Reset the variable
            canvas.renderAll();
        }


         function snapObject(target) {
             target.set({
                left: Math.round(target.left / gridSnapSize) * gridSnapSize,
                top: Math.round(target.top / gridSnapSize) * gridSnapSize
            });
         }

        function toggleSnap() {
            isSnapEnabled = !isSnapEnabled;

            if (isSnapEnabled) {
                showToast("Snap to grid enabled.");
                 canvas.on('object:moving', function(options) {
                     snapObject(options.target);
                 });
                 // Optional: Snap existing selection on toggle?
                 // const activeObj = canvas.getActiveObject();
                 // if(activeObj) { snapObject(activeObj); canvas.renderAll(); }
            } else {
                showToast("Snap to grid disabled.");
                canvas.off('object:moving'); // Remove only the snapping listener
                 // Re-add the basic history saver if it was overridden? No, history is separate.
            }
        }

        // --- Canvas Properties --- (resizeCanvas, resizeCanvasInternal, changeCanvasBackground - Unchanged)
         function resizeCanvas() {
            const width = parseInt(document.getElementById('canvasWidth').value);
            const height = parseInt(document.getElementById('canvasHeight').value);
            resizeCanvasInternal(width, height);
            saveToHistory(); // Consider if resizing should be in history
            showToast(`Canvas resized to ${width}x${height}px.`);
        }

        // Internal resize function to avoid loops with templates
        function resizeCanvasInternal(width, height) {
             // Update inputs if called internally
            document.getElementById('canvasWidth').value = width;
            document.getElementById('canvasHeight').value = height;

            canvas.setWidth(width);
            canvas.setHeight(height);
            // Re-draw grid if visible
            if (isGridVisible) {
                drawGrid();
            }
            canvas.renderAll();
        }

        function changeCanvasBackground(color) {
             document.getElementById('canvasBgColor').value = color; // Sync picker
             canvas.setBackgroundColor(color, canvas.renderAll.bind(canvas));
             saveToHistory();
        }

        // --- Effects ---
        const filterDefinitions = {
            brightness: {
            name: 'Brightness',
            fabricClass: fabric.Image.filters.Brightness,
            params: [
                { prop: 'brightness', label: 'Amount', type: 'range', min: -1, max: 1, step: 0.01, defaultValue: 0.1 }
            ]
        },
        contrast: {
            name: 'Contrast',
            fabricClass: fabric.Image.filters.Contrast,
            params: [
                { prop: 'contrast', label: 'Amount', type: 'range', min: -1, max: 1, step: 0.01, defaultValue: 0.1 }
            ]
        },
        saturation: {
            name: 'Saturation',
            fabricClass: fabric.Image.filters.Saturation,
            params: [
                { prop: 'saturation', label: 'Amount', type: 'range', min: -1, max: 1, step: 0.01, defaultValue: 0.2 }
            ]
        },
        blur: {
            name: 'Blur',
            fabricClass: fabric.Image.filters.Blur,
            params: [
                { prop: 'blur', label: 'Amount', type: 'range', min: 0, max: 1, step: 0.01, defaultValue: 0.1 }
            ]
        },
        noise: {
            name: 'Noise',
            fabricClass: fabric.Image.filters.Noise,
            params: [
                { prop: 'noise', label: 'Amount', type: 'range', min: 0, max: 1000, step: 10, defaultValue: 100 }
            ]
        },
        pixelate: {
            name: 'Pixelate',
            fabricClass: fabric.Image.filters.Pixelate,
            params: [
                { prop: 'blocksize', label: 'Block Size', type: 'range', min: 2, max: 30, step: 1, defaultValue: 8 }
            ]
        },
        grayscale: {
            name: 'Grayscale',
            fabricClass: fabric.Image.filters.Grayscale,
            params: [] // No parameters for basic grayscale
        },
        invert: {
            name: 'Invert',
            fabricClass: fabric.Image.filters.Invert,
            params: [] // No parameters
        },
        sepia: {
            name: 'Sepia',
            fabricClass: fabric.Image.filters.Sepia,
            params: [] // No parameters
        },
        sharpen: {
            name: 'Sharpen',
            fabricClass: fabric.Image.filters.Convolve,
            isConvolution: true, // Mark convolution filters
            params: [], // Fixed matrix for basic sharpen
            fixedMatrix: [  0, -1,  0, -1,  5, -1, 0, -1,  0 ]
        },
        emboss: {
            name: 'Emboss',
            fabricClass: fabric.Image.filters.Convolve,
            isConvolution: true,
            params: [], // Fixed matrix for basic emboss
            fixedMatrix: [ -2, -1, 0, -1,  1, 1, 0,  1, 2 ]
        }
        // Add more definitions here (e.g., Tint, Gamma, ColorMatrix - more complex)
    };

    function onFilterSelectChange() {
        const selectedFilterId = document.getElementById('filterSelect').value;
        const controlsContainer = document.getElementById('filterControlsContainer');
        controlsContainer.innerHTML = ''; // Clear previous controls

        if (selectedFilterId && filterDefinitions[selectedFilterId]) {
            const definition = filterDefinitions[selectedFilterId];

            if (definition.params.length > 0) {
                controlsContainer.innerHTML += `<h4>${definition.name} Options</h4>`;
                definition.params.forEach(param => {
                    const controlId = `filter-${selectedFilterId}-${param.prop}`;
                    let controlHtml = `<div class="form-group slider-control">`; // Use slider-control for consistent styling
                    controlHtml += `<label for="${controlId}">${param.label}`;
                    // Add span for value display next to label for ranges
                    if (param.type === 'range') {
                        controlHtml += ` <span id="${controlId}-value">${param.defaultValue}</span>`;
                    }
                    controlHtml += `</label>`;

                    if (param.type === 'range') {
                        controlHtml += `<input type="range" id="${controlId}" name="${param.prop}"
                                           min="${param.min}" max="${param.max}" step="${param.step}" value="${param.defaultValue}"
                                           oninput="updateFilterValueDisplay('${controlId}-value', this.value)">`;
                    } else if (param.type === 'number') {
                        // Add number input type if needed later
                        controlHtml += `<input type="number" id="${controlId}" name="${param.prop}"
                                           min="${param.min}" max="${param.max}" step="${param.step}" value="${param.defaultValue}" class="form-control">`;
                    } else if (param.type === 'color') {
                        // Add color input type if needed later
                         controlHtml += `<input type="color" id="${controlId}" name="${param.prop}" value="${param.defaultValue || '#000000'}" class="form-control" style="padding: 0; height: 25px;">`;
                    }
                    controlHtml += `</div>`;
                    controlsContainer.innerHTML += controlHtml;
                });
            } else {
                 controlsContainer.innerHTML = `<p><i>No adjustable parameters for ${definition.name}.</i></p>`;
            }
        }
    }

      // --- NEW: Helper to update slider value display ---
      function updateFilterValueDisplay(spanId, value) {
        const displaySpan = document.getElementById(spanId);
        if (displaySpan) {
            // Round value for display if it's a number
            const numValue = parseFloat(value);
            displaySpan.textContent = isNaN(numValue) ? value : numValue.toFixed(2);
        }
    }

    // --- NEW: Function to apply the currently selected filter with its parameters ---
    function applySelectedFilter() {
        const selectedFilterId = document.getElementById('filterSelect').value;
        const activeObject = canvas.getActiveObject();

        if (!selectedFilterId) {
            showToast("Please select a filter first.", "error");
            return;
        }
         if (!activeObject || activeObject.type !== 'image') {
            showToast("Please select an image first.", "error");
            return;
        }

        const definition = filterDefinitions[selectedFilterId];
        if (!definition) {
             showToast(`Invalid filter definition: ${selectedFilterId}`, "error");
             return;
        }

        // 1. Remove existing filter of the same type
        // Use the specific remove function which handles cache/render correctly
        removeFiltersOfType(activeObject, selectedFilterId, false); // false = Don't apply/render yet

        // 2. Collect parameter values from controls
        const filterOptions = {};
        if (definition.params.length > 0) {
             definition.params.forEach(param => {
                 const control = document.getElementById(`filter-${selectedFilterId}-${param.prop}`);
                 if (control) {
                     // Parse value as float for ranges/numbers
                     filterOptions[param.prop] = (param.type === 'range' || param.type === 'number')
                                                ? parseFloat(control.value)
                                                : control.value;
                 } else {
                     // Use default if control not found (shouldn't happen)
                     filterOptions[param.prop] = param.defaultValue;
                      console.warn(`Control not found for ${selectedFilterId} - ${param.prop}`);
                 }
             });
        }
         // Special handling for convolution filters with fixed matrices
         if (definition.isConvolution && definition.fixedMatrix) {
             filterOptions.matrix = definition.fixedMatrix;
         }

        // 3. Create new filter instance
        let newFilter;
        try {
            // Use spread syntax (...) if filterOptions is not empty, otherwise call constructor without args
             newFilter = Object.keys(filterOptions).length > 0
                        ? new definition.fabricClass(filterOptions)
                        : new definition.fabricClass();

             // Assign type manually if needed (esp. for generic classes like Convolve)
             if (definition.isConvolution) {
                 newFilter.filterType = selectedFilterId; // Store our custom ID
             }

        } catch (e) {
             console.error("Error creating filter instance:", e);
             showToast(`Failed to create filter: ${definition.name}`, "error");
             // Restore cache if needed after error?
             if (!activeObject.objectCaching) activeObject.objectCaching = true; // Simple restore attempt
             return;
        }


        // 4. Add and Apply
        activeObject.filters.push(newFilter);

        // --- Apply Filters & Manage Cache/Dirty ---
        const originalCacheState = activeObject.objectCaching;
        activeObject.objectCaching = false; // Disable cache
        activeObject.dirty = true;          // Mark dirty

        activeObject.applyFilters();
        canvas.renderAll();

        // Restore cache after delay
        setTimeout(() => {
            if (originalCacheState) {
                activeObject.objectCaching = true;
            }
        }, 50);
        // --- End Apply/Cache ---

        saveToHistory();
        showToast(`${definition.name} filter applied.`);
    }


    // --- NEW: Function to remove the currently selected filter type ---
    function removeSelectedFilterType() {
         const selectedFilterId = document.getElementById('filterSelect').value;
        const activeObject = canvas.getActiveObject();

        if (!selectedFilterId) {
            showToast("Please select a filter type to remove.", "error");
            return;
        }
         if (!activeObject || activeObject.type !== 'image') {
            showToast("Please select an image first.", "error");
            return;
        }

        const definition = filterDefinitions[selectedFilterId];
        if (!definition) {
             showToast(`Invalid filter definition: ${selectedFilterId}`, "error");
             return;
        }

        // Call the existing remove function, ensuring it applies and renders
        const removed = removeFiltersOfType(activeObject, selectedFilterId, true); // true = Apply and Render

        if (removed) {
             saveToHistory();
             showToast(`${definition.name} filter removed.`);
        } else {
             showToast(`${definition.name} filter was not found on the image.`, "info");
        }
    }




        

        function removeFiltersOfType(obj, filterIdToRemove, applyAndRender = true) {
        if (!obj || !obj.filters) return false;
        const originalLength = obj.filters.length;
        let filterRemoved = false;
        const definition = filterDefinitions[filterIdToRemove];

        obj.filters = obj.filters.filter(f => {
            let shouldKeep = true;
            // Try matching by stored custom type first (for convolutions)
            if (f.filterType === filterIdToRemove) {
                 shouldKeep = false;
            }
            // Fallback: Match by comparing Fabric class constructor names
            else if (definition && f.constructor === definition.fabricClass) {
                 // For non-parameterized or uniquely identifiable classes
                 if (!definition.params || definition.params.length === 0) {
                     shouldKeep = false;
                 }
                 // For parameterized filters, assume removing any instance of this class type is intended
                  // (More specific removal based on params is very complex)
                  else if (!definition.isConvolution) { // Don't remove all Convolves just because 'sharpen' was selected
                       shouldKeep = false;
                  }

            }

            if (!shouldKeep) filterRemoved = true;
            return shouldKeep;
        });

        // Apply and Render only if requested AND a filter was actually removed
        if (applyAndRender && filterRemoved) {
            const originalCacheState = obj.objectCaching;
            obj.objectCaching = false;
            obj.dirty = true;

            obj.applyFilters();
            canvas.renderAll();

            setTimeout(() => {
                if (originalCacheState) obj.objectCaching = true;
            }, 50);
        }
        return filterRemoved;
    }



    function removeFilters() {
         const activeObject = canvas.getActiveObject();
        if (!activeObject || activeObject.type !== 'image') {
            showToast("Select an image to remove effects.", "error");
            return;
        }

        if (activeObject.filters && activeObject.filters.length > 0) {
            activeObject.filters = []; // Clear all filters

            // --- START Cache/Dirty Management ---
            const originalCacheState = activeObject.objectCaching;
            activeObject.objectCaching = false; // Disable cache before applying
            activeObject.dirty = true;
             // --- END Cache/Dirty Management ---

            activeObject.applyFilters(); // Re-apply (which removes them)
            canvas.renderAll(); // Render after removing filters

             // --- START Restore Cache ---
             setTimeout(() => {
                 if (originalCacheState) activeObject.objectCaching = true;
             }, 50);
             // --- END Restore Cache ---

            saveToHistory();
            showToast("All effects removed from selected image.");
        } else {
             showToast("Selected image has no effects.", "error");
        }
    }


    function updateFilterControlsForSelection(imageObject) {
        if (!imageObject || imageObject.type !== 'image' || !imageObject.filters || imageObject.filters.length === 0) {
            // No image or no filters, reset the select and clear controls
            document.getElementById('filterSelect').value = "";
            onFilterSelectChange(); // Clear controls
            return;
        }

        // Find the *last* applied filter on the object (simplistic approach)
        // A more robust approach would need better filter identification
        const lastFilter = imageObject.filters[imageObject.filters.length - 1];
        let foundMatch = false;

        for (const id in filterDefinitions) {
            const definition = filterDefinitions[id];
            let match = false;

             // Check by stored custom type first
             if (lastFilter.filterType && lastFilter.filterType === id) {
                 match = true;
             }
             // Check by constructor
             else if (lastFilter.constructor === definition.fabricClass) {
                 // Special check for convolution - match only if matrix matches our definition
                 if (definition.isConvolution) {
                      if (definition.fixedMatrix && lastFilter.matrix && JSON.stringify(lastFilter.matrix) === JSON.stringify(definition.fixedMatrix)) {
                          match = true;
                      }
                 } else {
                      match = true; // Assume match for other classes
                 }
            }


            if (match) {
                document.getElementById('filterSelect').value = id;
                onFilterSelectChange(); // Generate controls for this filter

                // Now, populate the generated controls with the actual values from the lastFilter
                if (definition.params.length > 0) {
                    definition.params.forEach(param => {
                        const controlId = `filter-${id}-${param.prop}`;
                        const control = document.getElementById(controlId);
                        if (control && lastFilter[param.prop] !== undefined) {
                            control.value = lastFilter[param.prop];
                             // Update value display for sliders
                             if (param.type === 'range') {
                                 updateFilterValueDisplay(`${controlId}-value`, control.value);
                             }
                        }
                    });
                }
                foundMatch = true;
                break; // Stop after finding the first match (based on last filter)
            }
        }

        if (!foundMatch) {
             // If no matching definition found for the last filter, reset UI
            document.getElementById('filterSelect').value = "";
            onFilterSelectChange();
        }
    }

        // --- Saving & Downloading --- (Unchanged, but check grid removal logic)

        function downloadDesign() {
            const format = 'png'; // Or offer options like 'jpeg', 'svg'
            const quality = 1.0; // For JPEG
            const fileName = `${designName.replace(/ /g, '_')}.${format}`;

            // Temporarily hide grid elements for download
            const gridLayout = canvas.getObjects().find(obj => obj.name === 'grid_layout');
            const gridDrawing = canvas.getObjects().find(obj => obj.name === 'grid_drawing');
            const wasLayoutVisible = gridLayout && gridLayout.visible;
            const wasDrawingVisible = gridDrawing && gridDrawing.visible;

             if (gridLayout) gridLayout.set({ visible: false });
             if (gridDrawing) gridDrawing.set({ visible: false });
             // Only re-render if something was hidden
             if (wasLayoutVisible || wasDrawingVisible) canvas.renderAll();

            const dataURL = canvas.toDataURL({
                format: format,
                quality: quality,
                multiplier: 1 // Use 1 for actual size, increase for higher resolution export
            });

            // Restore grid visibility
            if (gridLayout) gridLayout.set({ visible: wasLayoutVisible });
            if (gridDrawing) gridDrawing.set({ visible: wasDrawingVisible });
            if (wasLayoutVisible || wasDrawingVisible) canvas.renderAll();


            const link = document.createElement('a');
            link.href = dataURL;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showToast(`Design downloaded as ${fileName}.`);
        }

        function saveDesign() {
            // Placeholder for saving logic (e.g., to localStorage, server)
            try {
                // Exclude grid elements from saved JSON if desired
                 const objectsToSave = canvas.getObjects().filter(obj => obj.name !== 'grid_layout' && obj.name !== 'grid_drawing');
                 const canvasJson = JSON.stringify({ version: fabric.version, objects: objectsToSave, background: canvas.backgroundColor });
                 // Alternatively save the whole canvas state: const canvasJson = JSON.stringify(canvas);

                localStorage.setItem('savedCanvasDesign', canvasJson);
                 localStorage.setItem('savedCanvasName', designName);
                showToast(`Design "${designName}" saved locally.`);
            } catch (e) {
                console.error("Error saving to localStorage:", e);
                showToast("Failed to save design locally. Storage might be full.", "error");
            }
        }

        // Function to load saved design
        function loadSavedDesign() {
            const savedJson = localStorage.getItem('savedCanvasDesign');
            const savedName = localStorage.getItem('savedCanvasName');
            if (savedJson) {
                 // Ensure drawing mode is off before loading
                 canvas.isDrawingMode = false;
                 currentDrawingTool = null;
                 document.getElementById('pencilBtn')?.classList.remove('active');
                 document.getElementById('eraserBtn')?.classList.remove('active');

                canvas.loadFromJSON(savedJson, () => {
                    canvas.renderAll();
                     // Restore history - simplified: start history with loaded state
                     canvasHistory = [savedJson];
                     currentHistoryIndex = 0;
                     document.getElementById('undoBtn').disabled = true;
                     document.getElementById('redoBtn').disabled = true;
                     updateLayers();
                     if (savedName) {
                         designName = savedName;
                         // Update button text more reliably
                         const nameButton = document.querySelector('.header-actions button:first-of-type');
                         if (nameButton) {
                              nameButton.childNodes[1].nodeValue = ` ${designName} `;
                         }
                     }
                     // Ensure canvas dimensions match saved state if they were saved implicitly
                      // Note: The provided save doesn't store width/height, so we rely on current settings or defaults
                     // resizeCanvasInternal(canvas.width, canvas.height);
                     showToast("Previously saved design loaded.");
                     // Re-draw visible grid if needed after loading
                     if(isGridVisible) drawGrid();
                });
            } else {
                // Don't show error if it's the first time loading
                // showToast("No saved design found.", "error");
            }
        }

        // --- Initialization ---
        function initCanvas() {
            updateCanvasSize(); // Initialize size from HTML inputs
            setupEventListeners(); // Setup base listeners
             // Load saved design first if available
            loadSavedDesign();
            // Only save initial state if no design was loaded
            if (currentHistoryIndex === -1) {
                saveToHistory();
            }
            updateLayers();
            resetControls(); // Ensure controls are in default state initially
        }

        // --- Modify setupEventListeners ---
        function setupEventListeners() {
            // --- Base Listeners ---
            canvas.on('object:modified', function(e) {
                 // Update arrowheads if an arrow group was modified
                 if (e.target && e.target.type === 'group' && e.target._line && e.target._head) {
                     updateArrowHeadPosition(e.target);
                 }
                 saveToHistory();
                 updateLayers();
                 updateControlsForSelection(); // Update controls after modification
            });
             canvas.on('object:added', function() { saveToHistory(); updateLayers(); });
             canvas.on('object:removed', function() { saveToHistory(); updateLayers(); });

             canvas.on('selection:created', updateControlsForSelection);
             canvas.on('selection:updated', updateControlsForSelection);
             canvas.on('selection:cleared', resetControls);

             // --- Text Editing Listener ---
             canvas.on('mouse:dblclick', function(options) {
                 if (options.target && (options.target.type === 'i-text' || options.target.type === 'textbox')) {
                     // Deactivate drawing mode if user double clicks text
                     if (canvas.isDrawingMode) {
                         toggleDrawingMode(currentDrawingTool);
                     }
                     options.target.enterEditing();
                     options.target.selectAll(); // Select all text on enter editing
                     canvas.renderAll();
                 }
             });

             // --- Text Editing Exit Listener ---
             canvas.on('text:editing:exited', function(options) {
                 if (options.target && (options.target.type === 'i-text' || options.target.type === 'textbox')) {
                     // Optionally remove object if text is empty?
                     // if (!options.target.text || options.target.text.trim() === '') {
                     //     canvas.remove(options.target);
                     // }
                     saveToHistory(); // Save state after text edit
                     updateLayers(); // Update layer name if text changed
                 }
             });


            // --- Drawing Path Creation Listener ---
            canvas.on('path:created', function(e) {
                // This event fires after a freehand path (pencil or eraser) is created
                if (currentDrawingTool === 'pencil' || currentDrawingTool === 'eraser') {
                     saveToHistory(); // Save the state after the path is drawn
                     updateLayers();
                }
            });

             // --- MODIFY Selection Listeners ---
         canvas.on('selection:created', (e) => {
            updateControlsForSelection(); // General controls
            if (e.selected && e.selected.length === 1 && e.selected[0].type === 'image') {
                updateFilterControlsForSelection(e.selected[0]); // Update filter UI
            } else {
                 updateFilterControlsForSelection(null); // Clear filter UI if not single image
            }
         });
         canvas.on('selection:updated', (e) => {
             updateControlsForSelection(); // General controls
             if (e.selected && e.selected.length === 1 && e.selected[0].type === 'image') {
                updateFilterControlsForSelection(e.selected[0]); // Update filter UI
            } else {
                 updateFilterControlsForSelection(null); // Clear filter UI if not single image
            }
         });
         canvas.on('selection:cleared', () => {
            resetControls(); // General controls
            updateFilterControlsForSelection(null); // Clear filter UI
        });


            // Handle window resize
            window.addEventListener('resize', () => {
                // Optional: Resize canvas relative to window? More complex.
                // For now, resizing is manual via controls.
                // updateCanvasSize();
                 // Re-draw grid on resize if visible
                 if (isGridVisible) { drawGrid(); }
            });
        }


        // --- Modify updateControlsForSelection ---
         function updateControlsForSelection() {
             resetControls(); // Start fresh
             const activeObject = canvas.getActiveObject();
             if (!activeObject) return;

             // Handle multiple selected objects (group or activeSelection)
             const isMultiple = activeObject.type === 'activeSelection';
             const target = isMultiple ? activeObject._objects[0] : activeObject; // Use first object for multi-select defaults

             if (!target) return; // Should not happen, but safety check

             // --- Update General Style Controls ---
             // Update color picker (use fill of first object, or default if mixed/gradient)
             if (target.fill && !(target.fill instanceof fabric.Gradient)) {
                 document.getElementById('colorPicker').value = target.fill;
             } else if (target.fill instanceof fabric.Gradient) {
                 // Indicate gradient in UI? Maybe disable solid color picker?
                 // document.getElementById('colorPicker').value = '#ffffff'; // Reset picker
                 // Or better: update gradient controls if possible
                  document.getElementById('gradientColor1').value = target.fill.colorStops[0].color;
                  document.getElementById('gradientColor2').value = target.fill.colorStops[1].color; // Assuming 2 stops
                  document.getElementById('gradientType').value = target.fill.type;
             } else {
                 // Default if no fill (e.g., line) or transparent
                  document.getElementById('colorPicker').value = '#000000';
             }

             // Update opacity slider
             document.getElementById('opacitySlider').value = (target.opacity || 1) * 100;
             document.getElementById('opacityValue').innerText = Math.round((target.opacity || 1) * 100) + '%';

             // Update border width
             const strokeWidth = target.strokeWidth || 0;
             document.getElementById('borderWidthSlider').value = strokeWidth;
             document.getElementById('borderWidthValue').innerText = strokeWidth + 'px';

             // Update border color
             document.getElementById('borderColorPicker').value = target.stroke || '#000000';


             // --- Update Text Controls (if applicable) ---
             if (!isMultiple && (target.type === 'i-text' || target.type === 'textbox')) {
                 document.getElementById('fontSizeSlider').value = target.fontSize || 20;
                 document.getElementById('fontSizeValue').innerText = (target.fontSize || 20) + 'px';

                 // Update font family
                 if (target.fontFamily) {
                     document.getElementById('fontSelect').value = target.fontFamily;
                      // Fallback if font isn't exact match in list
                      if (document.getElementById('fontSelect').value !== target.fontFamily) {
                          // Find partial match or default
                           const fontSelect = document.getElementById('fontSelect');
                           let found = false;
                            for (let i = 0; i < fontSelect.options.length; i++) {
                                if (fontSelect.options[i].value.toLowerCase().includes(target.fontFamily.toLowerCase())) {
                                    fontSelect.selectedIndex = i;
                                    found = true;
                                    break;
                                }
                            }
                           if (!found) fontSelect.selectedIndex = 0; // Default to Arial if not found
                      }
                 }

                 // Update style buttons
                 document.getElementById('boldBtn').classList.toggle('active', target.fontWeight === 'bold');
                 document.getElementById('italicBtn').classList.toggle('active', target.fontStyle === 'italic');
                 document.getElementById('underlineBtn').classList.toggle('active', target.underline === true);
             }
         }


         // --- Modify resetControls ---
          function resetControls() {
            // Reset general style controls
            document.getElementById('colorPicker').value = '#000000'; // Default fill color
            document.getElementById('opacitySlider').value = 100;
            document.getElementById('opacityValue').innerText = '100%';
            document.getElementById('borderWidthSlider').value = 1; // Default border width 1? or 0? Let's use 1.
            document.getElementById('borderWidthValue').innerText = '1px';
            document.getElementById('borderColorPicker').value = '#000000'; // Default border color

            // Reset gradient controls
            document.getElementById('gradientType').value = 'linear';
            document.getElementById('gradientColor1').value = '#ffffff';
            document.getElementById('gradientColor2').value = '#000000';

            // Reset text controls
            document.getElementById('fontSizeSlider').value = 20;
            document.getElementById('fontSizeValue').innerText = '20px';
            document.getElementById('fontSelect').selectedIndex = 0; // Default to Arial

            // Reset text style buttons
            document.getElementById('boldBtn').classList.remove('active');
            document.getElementById('italicBtn').classList.remove('active');
            document.getElementById('underlineBtn').classList.remove('active');

             // Don't reset active drawing tool here, just the visual controls
        }


   
        document.addEventListener('DOMContentLoaded', () => {
    initCanvas();
    
    // Try to load saved credentials
    const savedCredentials = localStorage.getItem('figmaCredentials');
    if (savedCredentials) {
        figmaCredentials = JSON.parse(savedCredentials);
        document.getElementById('figmaClientId').value = figmaCredentials.clientId;
        document.getElementById('figmaSecretId').value = figmaCredentials.secretId;
        fetchTemplatePreviews(); // Auto-load if credentials exist
    }
    
    // Set up event listeners for credential buttons
    document.getElementById('saveCredentials').addEventListener('click', saveCredentials);
    document.getElementById('loadTemplates').addEventListener('click', fetchTemplatePreviews);
});
</script>

   
